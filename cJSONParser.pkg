// cJSONParser class v1.13:
// Created by Erik Svensson and published on eriksven.com in April 2013
// License: LGPLv3 - GNU LESSER GENERAL PUBLIC LICENSE Version 3 - http://www.gnu.org/licenses/lgpl.txt

Define cJSONPARSER_INCLUDED for 1

#IFNDEF cJSONDICTIONARY_INCLUDED
Use cJSONDictionary.pkg
#ENDIF

#IFNDEF cREGEX_INCLUDED
Use cRegex.pkg
#ENDIF

Define JSON_TOKEN for Integer
Define JSON_TOKEN_NONE for 0
Define JSON_TOKEN_CURLY_OPEN for 1
Define JSON_TOKEN_CURLY_CLOSE for 2
Define JSON_TOKEN_SQUARED_OPEN for 3
Define JSON_TOKEN_SQUARED_CLOSE for 4
Define JSON_TOKEN_COLON for 5
Define JSON_TOKEN_COMMA for 6
Define JSON_TOKEN_STRING for 7
Define JSON_TOKEN_NUMBER for 8
Define JSON_TOKEN_TRUE for 9
Define JSON_TOKEN_FALSE for 10
Define JSON_TOKEN_NULL for 11

Register_Function _ParseValue UChar[] ByRef json Integer ByRef idx Boolean ByRef success Returns Variant

Class cJSONParser is a cObject
    
    Procedure Construct_Object
        Forward Send Construct_Object
        Property UChar[] pucWhitespace
        Property UChar[] pucNumbers
        Property String psDecimalSeparator
        Property _jsond_type pLastType
        Property Handle phTopObject
        Property Integer piLevel 0
        Property Boolean pbAutoParseMicrosoftDates False
            
        UChar[] whitespace
        Move 9 to whitespace[0]
        Move 10 to whitespace[1]
        Move 13 to whitespace[2]
        Move 32 to whitespace[3]
        Set pucWhitespace to whitespace
        
        UChar[] numbers
        Move (Ascii('0')) to numbers[0]
        Move (Ascii('1')) to numbers[1]
        Move (Ascii('2')) to numbers[2]
        Move (Ascii('3')) to numbers[3]
        Move (Ascii('4')) to numbers[4]
        Move (Ascii('5')) to numbers[5]
        Move (Ascii('6')) to numbers[6]
        Move (Ascii('7')) to numbers[7]
        Move (Ascii('8')) to numbers[8]
        Move (Ascii('9')) to numbers[9]
        Move (Ascii('+')) to numbers[10]
        Move (Ascii('-')) to numbers[11]
        Move (Ascii('.')) to numbers[12]
        Move (Ascii('e')) to numbers[13]
        Move (Ascii('E')) to numbers[14]
        Set pucNumbers to numbers
        
        Integer iDecimalSeparator
        Get_Attribute DF_DECIMAL_SEPARATOR to iDecimalSeparator
        Set psDecimalSeparator to (Character(iDecimalSeparator))
    End_Procedure
    
    { Visibility=Public }
    Function Is_cJSONParser Returns Boolean
        Function_Return True
    End_Function
    
    Procedure _Increment
        Set piLevel to (piLevel(Self)+1)
    End_Procedure
    
    Procedure _Decrement
        Set piLevel to (piLevel(Self)-1)
    End_Procedure
    
    Function _IsMicrosoftDate String s Returns Boolean
        If (not(pbAutoParseMicrosoftDates(Self))) Function_Return False
        Function_Return (Regex_IsMatch(s, '^\/Date\(\d+((\-|\+)\d{4})?\)\/$', True))
    End_Function
    
    Function _ParseMicrosoftDate String s Returns DateTime
        BigInt iDate iDays iDateOffset
        Integer HH MM SS MS
        DateTime dt1970 dtRetVal
        Date d1970 dDate
        TimeSpan ts
        Get Regex_Replace s "$1" "\/Date\((-?\d+)(\)|-\d+\))\/" True to iDate
        Move (DateSetYear(dt1970, 1970)) to dt1970
        Move (DateSetMonth(dt1970, 1)) to dt1970
        Move (DateSetDay(dt1970, 1)) to dt1970      
        Move (((((iDate/1000)/60)/60)/24)/1) to iDays
        Move (iDate - (iDays * 1000 * 60 * 60 * 24)) to iDateOffset
        Move (((iDateOffset / 1000) / 60) / 60) to HH
        Move (((iDateOffset / 1000) / 60) - (HH*60)) to MM
        Move ((iDateOffset / 1000) - ((HH*60*60) + (MM*60))) to SS
        Move ((iDateOffset) - ((HH*60*60*1000) + (MM*60*1000) + (SS*1000))) to MS
        Move dt1970 to d1970
        Move (d1970 + iDays) to dDate
        Move dDate to dtRetVal
        Move (DateSetHour(dtRetVal, HH)) to dtRetVal
        Move (DateSetMinute(dtRetVal, MM)) to dtRetVal
        Move (DateSetSecond(dtRetVal, SS)) to dtRetVal
        Move (DateSetMillisecond(dtRetVal, MS)) to dtRetVal
        Function_Return dtRetVal
    End_Function
    
    Procedure _EatWhitespace UChar[] ByRef json Integer ByRef idx
        UChar[] whitespace
        Get pucWhitespace to whitespace
        While (idx < SizeOfArray(json))
            If (SearchArray(json[idx], whitespace) = -1) Break
            Increment idx 
        Loop
    End_Procedure
    
    Function _GetLastIndexOfNumber UChar[] ByRef json Integer idx Returns Integer
        UChar[] numbers
        Get pucNumbers to numbers
        Integer lastIndex
        For lastIndex from idx to (SizeOfArray(json)-1)
            If (SearchArray(json[lastIndex], numbers) = -1) Break
        Loop
        Function_Return (lastIndex-1)
    End_Function
    
    Function _NextToken UChar[] ByRef json Integer ByRef idx Returns JSON_TOKEN
        Send _EatWhitespace (&json) (&idx)
        If (idx = SizeOfArray(json)) Function_Return JSON_TOKEN_NONE
        
        UChar c
        Move json[idx] to c
        Increment idx
        Case Begin
            Case (c = Ascii('{'))
                Function_Return JSON_TOKEN_CURLY_OPEN
                Case Break
            Case (c = Ascii('}'))
                Function_Return JSON_TOKEN_CURLY_CLOSE
            Case Break
            
            Case (c = Ascii('['))
                Function_Return JSON_TOKEN_SQUARED_OPEN
            Case Break
            
            Case (c = Ascii(']'))
                Function_Return JSON_TOKEN_SQUARED_CLOSE
            Case Break
            
            Case (c = Ascii(','))
                Function_Return JSON_TOKEN_COMMA
            Case Break
            
            Case (c = Ascii('"'))
                Function_Return JSON_TOKEN_STRING
            Case Break
            
            Case (c = Ascii('0') or c = Ascii('1') or c = Ascii('2') or c = Ascii('3') or c = Ascii('4') or ;
                  c = Ascii('5') or c = Ascii('6') or c = Ascii('7') or c = Ascii('8') or c = Ascii('9') or ;
                  c = Ascii('-'))
                Function_Return JSON_TOKEN_NUMBER
            Case Break
            
            Case (c = Ascii(':'))
                Function_Return JSON_TOKEN_COLON
            Case Break
        Case End
        Decrement idx
        
        Integer remainingLength
        Move (SizeOfArray(json) - idx) to remainingLength
        
        // false
        If (remainingLength >= 5) Begin
            If (json[idx] = Ascii('f') and ;
                json[idx + 1] = Ascii('a') and ;
                json[idx + 2] = Ascii('l') and ;
                json[idx + 3] = Ascii('s') and ;
                json[idx + 4] = Ascii('e')) Begin
                    Add 5 to idx
                    Function_Return JSON_TOKEN_FALSE
                End
        End
        
        // true
        If (remainingLength >= 4) Begin
           If (json[idx] = Ascii('t') and ;
               json[idx + 1] = Ascii('r') and ;
               json[idx + 2] = Ascii('u') and ;
               json[idx + 3] = Ascii('e')) Begin
                    Add 4 to idx
                    Function_Return JSON_TOKEN_TRUE 
               End
        End
        
        // null
        If (remainingLength >= 4) Begin
           If (json[idx] = Ascii('n') and ;
               json[idx + 1] = Ascii('u') and ;
               json[idx + 2] = Ascii('l') and ;
               json[idx + 3] = Ascii('l')) Begin
                    Add 4 to idx
                    Function_Return JSON_TOKEN_NULL 
               End
        End
        
        Function_Return JSON_TOKEN_NONE
    End_Function
    
    Function _LookAhead UChar[] ByRef json Integer idx Returns Integer
        Integer saveIdx
        Move idx to saveIdx
        Function_Return (_NextToken(Self, (&json), (&saveIdx)))
    End_Procedure
    
    Function _ParseString UChar[] ByRef json Integer ByRef idx Boolean ByRef success Returns String
        UChar c
        String s
        
        Send _EatWhitespace (&json) (&idx)
        
        // "
        Increment idx
        Move json[idx] to c
        Boolean complete
        
        Move "" to s
        
        While (not(complete))
            If (idx = SizeOfArray(json)) Break

            If (c = Ascii('"')) Begin
                Move True to complete
            End
            If (complete) Break
            
            If (c = Ascii('\')) Begin
                
                If (idx = SizeOfArray(json)) Break
                
                Increment idx
                Move json[idx] to c

                If (c = Ascii('"')) Append s '"'
                Else If (c = Ascii('\')) Append s '\'
                Else If (c = Ascii('/')) Append s '/'
                Else If (c = Ascii('b')) Append s (Character(8))
                Else If (c = Ascii('f')) Append s (Character(12))
                Else If (c = Ascii('n')) Append s (Character(10))
                Else If (c = Ascii('r')) Append s (Character(13))
                Else If (c = Ascii('t')) Append s (Character(9))
                
            End
            Else Begin
                Append s (Character(json[idx]))
            End
            
            Increment idx
            Move json[idx] to c
        Loop
        
        Increment idx
        
        If (not(complete)) Begin
            Move False to success
            Function_Return NULL_ENTRY
        End
        
        If (_IsMicrosoftDate(Self, s)) Begin
            Get _ParseMicrosoftDate s to s
        End
        
        Function_Return s
    End_Function
    
    Function _ParseNumber UChar[] ByRef json Integer ByRef idx Boolean ByRef success Returns Number
        Integer lastIndex i
        String sNumber
        Number n
        Send _EatWhitespace (&json) (&idx)
        
        Move "" to sNumber
        Get _GetLastIndexOfNumber (&json) idx to lastIndex
        For i from idx to lastIndex
            Append sNumber (Character(json[i]))
        Loop
        Move (Replace(".", sNumber, psDecimalSeparator(Self))) to n
        Move (lastIndex+1) to idx
        Function_Return n
    End_Function
    
    Function _ParseObject UChar[] ByRef json Integer ByRef idx Boolean ByRef success Returns Handle
        JSON_TOKEN token
        Handle table
        String name
        Variant value
        
        If (piLevel(Self) = 1) Move (phTopObject(Self)) to table
        Else Get Create of (phTopObject(Self)) U_cJSONDictionary to table
        
        Boolean done
        Move (_NextToken(Self, (&json), (&idx))) to token
        While (not(done))
            Move (_LookAhead(Self, (&json), (&idx))) to token
            If (token = JSON_TOKEN_NONE) Begin
                Send Destroy of table
                Move False to success
                Function_Return 0        
            End
            Else If (token = JSON_TOKEN_COMMA) Begin
                Move (_NextToken(Self, (&json), (&idx))) to token
            End
            Else If (token = JSON_TOKEN_CURLY_CLOSE) Begin
                Move (_NextToken(Self, (&json), (&idx))) to token
                Set pLastType to _jsond_object
                Send _Decrement
                Function_Return table
            End
            Else Begin
                
                // name
                Move (_ParseString(Self, (&json), (&idx), (&success))) to name
                If (not(success)) Begin
                    Send Destroy of table
                    Move False to success
                    Function_Return 0  
                End
                
                Move (_NextToken(Self, (&json), (&idx))) to token
                
                // :
                If (token <> JSON_TOKEN_COLON) Begin
                    Send Destroy of table
                    Move False to success
                    Function_Return 0 
                End
                
                // value
                Get _ParseValue (&json) (&idx) (&success) to value
                If (not(success)) Begin
                    Send Destroy of table
                    Move False to success
                    Function_Return 0  
                End
                
                Set TypedValue of table name (pLastType(Self)) to value
                
            End
        Loop
        
        Set pLastType to _jsond_object
        Function_Return table
    End_Function

    Function _ParseArray UChar[] ByRef json Integer ByRef idx Boolean ByRef success Returns Variant[]
        Variant[] nArray arrayNull
        Boolean done
        JSON_TOKEN token
        Variant value
        _jsond_type lastType
        
        Move _jsond_array to lastType
        Move (_NextToken(Self, (&json), (&idx))) to token
        While (not(done))
            Move (_LookAhead(Self, (&json), (&idx))) to token
            If (token = JSON_TOKEN_NONE) Begin
                Move False to success
                Function_Return arrayNull      
            End
            Else If (token = JSON_TOKEN_COMMA) Begin
                Move (_NextToken(Self, (&json), (&idx))) to token
            End
            Else If (token = JSON_TOKEN_SQUARED_CLOSE) Begin
                Move (_NextToken(Self, (&json), (&idx))) to token
                Set pLastType to lastType
                Send _Decrement
                Function_Return nArray
            End
            Else Begin
                Move (_ParseValue(Self, (&json), (&idx), (&success))) to value
                If (pLastType(Self) = _jsond_object) Begin
                    Move _jsond_object_array to lastType
                End
                If (not(success)) Begin
                    Move False to success
                    Function_Return arrayNull   
                End
                Move value to nArray[SizeOfArray(nArray)]
            End
        Loop
        Set pLastType to lastType
        Function_Return nArray
    End_Function

    Function _ParseValue UChar[] ByRef json Integer ByRef idx Boolean ByRef success Returns Variant
        Integer lookAhead
        JSON_TOKEN token
        Get _LookAhead (&json) idx to lookAhead
        
        Case Begin
            
            Case (lookAhead = JSON_TOKEN_STRING)
                Set pLastType to _jsond_string
                Function_Return (_ParseString(Self, (&json), (&idx), (&success)))
            Case Break
            
            Case (lookAhead = JSON_TOKEN_NUMBER)
                Set pLastType to _jsond_number
                Function_Return (_ParseNumber(Self, (&json), (&idx), (&success)))
            Case Break
            
            Case (lookAhead = JSON_TOKEN_CURLY_OPEN)
                Set pLastType to _jsond_object
                Send _Increment
                Function_Return (_ParseObject(Self, (&json), (&idx), (&success)))
            Case Break
            
            Case (lookAhead = JSON_TOKEN_SQUARED_OPEN)
                Set pLastType to _jsond_array
                Send _Increment
                Function_Return (_ParseArray(Self, (&json), (&idx), (&success)))
            Case Break
            
            Case (lookAhead = JSON_TOKEN_TRUE)
                Move (_NextToken(Self, (&json), (&idx))) to token
                Set pLastType to _jsond_bool
                Function_Return True
            Case Break
            
            Case (lookAhead = JSON_TOKEN_FALSE)
                Move (_NextToken(Self, (&json), (&idx))) to token
                Set pLastType to _jsond_bool
                Function_Return False
            Case Break
            
            Case (lookAhead = JSON_TOKEN_NULL)
                Move (_NextToken(Self, (&json), (&idx))) to token
                Set pLastType to _jsond_null
                Function_Return NULL_ENTRY
            Case Break
            
            Case (lookAhead = JSON_TOKEN_NONE)
            Case Break
            
        Case End
        
        Move False to success
        
        Function_Return NULL_ENTRY
    End_Procedure

    Procedure _ToCharArray String ByRef s UChar[] ByRef ca
        Address aStr
        Move (ResizeArray(ca,Length(s))) to ca
        Move (AddressOf(ca)) to aStr
        Move s to aStr
    End_Procedure
    
    { Visibility=Public }
    Procedure Parse String sJson Handle Out_hJSONDictionary
        Variant v
        Variant[] va
        UChar[] json
        Integer idx
        Boolean success
        Boolean bIsObject
        
        Set phTopObject to Out_hJSONDictionary
        
        Move True to success
        Send _ToCharArray (&sJson) (&json)
        Get _ParseValue (&json) (&idx) (&success) to v
        If (not(success)) Begin
            Move False to Found
            Move True to FindErr
            Procedure_Return
        End
        
        Send Ignore_Error of Error_Object_Id 4381
        Move False to Err
        Move v to va
        Move Err to bIsObject
        Send Trap_Error of Error_Object_Id 4381
        
        If (not(bIsObject)) Begin
            Set Value of Out_hJSONDictionary "_array" to va
        End
        
        Move True to Found
        Move False to FindErr
    End_Procedure    

End_Class